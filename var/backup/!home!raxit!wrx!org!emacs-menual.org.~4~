#+TITLE: EMACS KEYBINDINGS
#+AUTHOR: Likhon Barai
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-dark.min.css" />

* Projectile
- Simply open any file in the git project using =C-x C-f= and then try running
  command ~C-c p f~.

+ Opening a file in a git project will make projectile recognize the project.

- I think your project is indeed considered a project by =projectile= only if you
  have a =.git= folder in it (did you forget to =git init=?). I'm not seeing one in
  your case. You can alternatively add a =.projectile= file instead. Everything in
  that folder containing the =.projectile= file and all subfolders will be
  considered part of the same project.

* ORG
- C-c C-, (org-insert-structure-template)
for farther explanation, [[https://orgmode.org/manual/Structure-Templates.html#Structure-Templates][go here]]

also put this in your init.el
- (require 'org-tempo)

#+begin_src
a	‚Äò#+BEGIN_EXPORT ascii‚Äô ‚Ä¶ ‚Äò#+END_EXPORT‚Äô
c	‚Äò#+BEGIN_CENTER‚Äô ‚Ä¶ ‚Äò#+END_CENTER‚Äô
C	‚Äò#+BEGIN_COMMENT‚Äô ‚Ä¶ ‚Äò#+END_COMMENT‚Äô
e	‚Äò#+BEGIN_EXAMPLE‚Äô ‚Ä¶ ‚Äò#+END_EXAMPLE‚Äô
E	‚Äò#+BEGIN_EXPORT‚Äô ‚Ä¶ ‚Äò#+END_EXPORT‚Äô
h	‚Äò#+BEGIN_EXPORT html‚Äô ‚Ä¶ ‚Äò#+END_EXPORT‚Äô
l	‚Äò#+BEGIN_EXPORT latex‚Äô ‚Ä¶ ‚Äò#+END_EXPORT‚Äô
q	‚Äò#+BEGIN_QUOTE‚Äô ‚Ä¶ ‚Äò#+END_QUOTE‚Äô
s	‚Äò#+BEGIN_SRC‚Äô ‚Ä¶ ‚Äò#+END_SRC‚Äô
v	‚Äò#+BEGIN_VERSE‚Äô ‚Ä¶ ‚Äò#+END_VERSE‚Äô
#+end_src

* Hideshow minor mode

Here‚Äôs the keymap for folding-related functions in the two modes:
| Key binding | Hideshow mode    | Key binding | Outline minor mode     |
| C-c @ C-a   | hs-show-all      | C-c @ TAB   | outline-show-children  |
| C-c @ C-c   | hs-toggle-hiding | C-c @ C-k   | outline-show-branches  |
| C-c @ C-d   | hs-hide-block    | C-c @ C-o   | outline-hide-other     |
| C-c @ C-e   | hs-toggle-hiding | C-c @ C-q   | outline-hide-sublevels |
| C-c @ C-h   | hs-hide-block    |             |                        |
| C-c @ C-l   | hs-hide-level    |             |                        |
| C-c @ C-s   | hs-show-block    |             |                        |
| C-c @ C-t   | hs-hide-all      |             |                        |
| C-c @ ESC   | Prefix Command   |             |                        |
| C-c @ C-M-h | hs-hide-all      |             |                        |
| C-c @ C-M-s | hs-show-all      |             |                        |

+ This is irritating on two levels.
1. The key bindings are on a difficult to use keymap.
2. There‚Äôs no easy entry point and there are too many commands to do simple
   tasks.


| Keybindings | Description                                              |
| C-c @ C-h   | Hide the current block (hs-hide-block)                   |
| C-c @ C-d   | "...................."                                   |
| C-c @ C-s   | Show the current block (hs-show-block)                   |
| C-c @ C-c   | Either hide or show the current block (hs-toggle-hiding) |
| C-c @ C-e   | ...........................                              |

*S-mouse-2* - Toggle hiding for the block you click on (hs-mouse-toggle-hiding).
| Key-bindings    | Description                                               |
| C-c @ C-M-h     | Hide all top-level blocks (hs-hide-all)                   |
| C-c @ C-t       | ......................                                    |
| C-c @ C-M-s     | Show all blocks in the buffer (hs-show-all)               |
| C-c @ C-a       | ...................                                       |
| C-u n C-c @ C-l | Hide all blocks n levels below this block (hs-hide-level) |

- These variables can be used to customize Hideshow mode:
+ If non-nil, C-c @ C-M-h (hs-hide-all) hides comments too.

- ~hs-isearch-open~
    Specifies what kind of hidden blocks to open in Isearch mode. The value should be one of these four symbols.

    =code=
        Open only code blocks.
    =comment=
        Open only comments.
    ~t~
        Open both code blocks and comments.
    ~nil~
        Open neither code blocks nor comments.

- ~hs-special-modes-alist~
    A list of elements, each specifying how to initialize Hideshow variables for one major mode. See the variable's documentation string for more information.
* Enter Numeric valus
- Insert number input trough a significant point ~C-10 C-u 0~ this will enter 10
  zeros after the point.
[-] [X] [ ] -> :kissing_heart: üç≠üîñüìöüêÑüí†
- *C-x C-b o* to view a file in /other window/.
* Display line number
- M-x d-nu RET
* Formatting paragraph with shell cmnd
- First select the region for formatted then enter into shell by pressing ~M-!~.
  And then enter command ~fmt -w 80~f

- M-|               - runs the command shell-command-on-region

- C-u M-|           - run shell command in buffer region

- C-h i m emacs RET - guide to learning Emacs Lisp for non-programmers for
  reference. * The Emacs Lisp Reference *

* Moving around on Emacs
** make cursor jump back to the previous position?
- C-SPC C-SPC
  -  In Emacs you can save the position of the cursor by pressing ~C-space C-space~.
  - set mark (activates and then deactivates region) pushes the
    current position to the mark ring (without leaving it active).

- C-u C-SPC
  - When you are in another part of the document, jump back with
    ~C-u C-space~.
  - move to previous mark pops the mark ring, jumping to the
    previous position. You can use this repeatedly to navigate
    through the entire ring.

- C-x C-x
  - exchange-point-and-mark

  - Put the mark where point is now, and point where the
    mark is now.  This command works even when the mark is
    not active, and it reactivates the mark.

  - If Transient Mark mode is on, a prefix ARG deactivates
    the mark if it is active, and otherwise avoids
    reactivating it.  If Transient Mark mode is off, a
    prefix ARG enables Transient Mark mode temporarily.

- C-x C-@ and C-x C-SPC

  - (pop-global-mark) Pop off global mark ring and jump to
    the top location.  The global mark ring is updated
    automatically

* Registers:
** Save Positions in Registers:
- C-x r SPC
  - runs point-to-register

- C-x r j
  - runs jump-to-register
  Type any character to specify a register when prompted.

- C-x r C-SPC

- C-x r C-@
  - (point-to-register REGISTER &optional ARG)

* Search:
- M-p
  - select PREVIOUS search string
- M-n
  - select NEXT search string

* Help Menu:
- C-h i m
  - go to info and SELECT *m* for menu

- C-h a
  - Show commands (interactively callable functions) that
    match PATTERN.  PATTERN can be a word, a list of words
    (separated by spaces), or a regexp (using some regexp
    special characters).  If it is a word, search for
    matches for that word as a substring.  If it is a list
    of words, search for matches for any two (or more) of
    those words.

- C-x l
  - Report number of lines on current page, and how many are before or after point.

* Bookmarks:

- C-x r m 	runs bookmark-set
- C-x r b 	runs bookmark-jump
- C-x r l 	list of your Bookmarks you've already save
- DELETE		go ot Bookmark and SELECT by pressing ~d~ than to delete press ~x~

Note that some commands (especially ones which are liable to move you an an
unknown or arbitrary distance from your original location) will automatically
push to the mark ring so that you can use ~C-u C-SPC~ to return afterwards. This
includes isearch, so after using C-s to go somewhere, you can easily jump back
again.

* Exchange point and mark:
- C-x C-x runs exchange-point-and-mark which is very useful for jumping between
  two locations. It also activates the mark/region,
 use C-SPC to
  clear the highlighting.

1. If you're taking advantage of register functionality in elisp, use some non-conflicting symbol for the name, rather than a char, so that you can't conflict with interactively-set registers (unless, of course, you want to do that).

- C-x r SPC r

  - Record the position of point and the current buffer in register r (point-to-register).

- C-x r j r

  - Jump to the position and buffer saved in register r
    (jump-to-register).

Typing C-x r SPC (point-to-register), followed by a character r, saves both the position of point and the current buffer in register r. The register retains this information until you store something else in it.

The command C-x r j r switches to the buffer recorded in register r, pushes a mark, and moves point to the recorded position. (The mark is not pushed if point was already at the recorded position, or in successive calls to the command.) The contents of the register are not changed, so you can jump to the saved position any number of times.

If you use C-x r j to go to a saved position, but the buffer it was saved from has been killed, C-x r j tries to create the buffer again by visiting the same file. Of course, this works only for buffers that were visiting files.

* Keyboard Macros
- C-x (:      - Start recording key strokes.

- C-x ):        Stop recording key strokes and save recording as a replayable keyboard macro.

- C-x e:        Replay the keyboard macro. Type e after typing this once to play it again.

- C-a 	C-SPACE 	C-n		 M-w	 C-y	---Duplicate a whole line
- CTRL-A	CTRL-K	 CTRL-K	 CTRL-Y	 CTRL-Y		---Duplicate a whole line

- C-x C-e ;; execute current line elisp
- C-x s 	---Save-some-buffer, giving the choice which buffer to save or not:

- M-a or M-e 			---M-a runs the command backward-sentence And M-e runs the command forward-sentence.

- M-x eval-region ;; region
- M-x eval-buffer ;; whole buffer
- M-x load-file ~/.emacs.d/init.el
- M-x revert-buffer

narrow-to-region (C-x n n) Then widen (C-x n w)

;; You can also just move the point to the end of any sexp and press
C-x C-e 	---to execute just that sexp. ;; Usually it's not necessary to reload the whole file if you're just changing a line or two.

M-: (load user-init-file)
;; you type it in Eval: prompt (including the parentheses)
;; user-init-file is a variable holding the ~/.emacs value (pointing to the configuration file path) by default
;; (load) is shorter, older, and non-interactive version of (load-file); it is not an emacs command (to be typed in M-x) but a mere elisp function

M-/ 	     - EXPAND ABBREVIATION - the command abbrev-expand, is an autoloaded interactive compiled Lisp function

C-M-o
Split line at point; text on the line after point becomes a new line indented to the same column that it now starts in (split-line).
M-m
Move (forward or back) to the first nonblank character on the current line (back-to-indentation).
C-M-\
Indent several lines to same column (indent-region).
C-q TAB
Insert a literal \T into your code somewhere.
C-x TAB
Shift block of lines rigidly right or left (indent-rigidly).
M-i
Indent from point to the next prespecified tab stop column (tab-to-tab-stop).
M-x indent-relative
Indent from point to under an indentation point in the previous line.

C-5 C-x TAB  ---you can specify the number of spaces to indent by using a prefix argument

C-x r t	     ---(M-x string-rectangle) This one inserts text at every line in the rectangle.

%% Start by setting the mark at the beginning of the first line, and move your cursor to the first character of the last line you want to prefix:

#+BEGIN_EXAMPLE
*Hello
There
‚ñÆI am some code
#+END_EXAMPLE

%% Then use C-x r t, enter your prefix (I said) and press RET. This adds the text to each line in the rectangle:

I said Hello
I said There
I said I am some code

%% If you don't line up your cursor on the same column as your mark, it will overwrite that part of the rectangle:

#+BEGIN_EXAMPLE
*Hello
There
I am‚ñÆ some code
#+END_EXAMPLE

%% with the same command results in:

#+BEGIN_EXAMPLE
I said o
I said e
I said  some code
#+END_EXAMPLE

- C-x r t       - string-rectangle (used to insert any arbitrary text (spaces included) in a selected region.)

%% Let's say you have this block of text and you want to insert 5 spaces in front of all lines.

abc
def
ghi

- C-x r t M-5 SPC RET   - That will give the below force indented text.
#+BEGIN_EXAMPLE
abc
def
ghi
#+END_EXAMPLE

%% for example, if you wanted a yellow bar 5 pixels wide in insert state and a
purple-filled box in normal state, you could do the following:
#+BEGIN_SRC emacs-lisp
(setq evil-insert-state-cursor '((bar . 5) "yellow")
evil-normal-state-cursor '(box "purple"))
#+END_SRC

- IMHO the standard way is:
   1) Go to the top of your buffer.
   2) Type C-M-% for query-replace-regexp.
   3) Input ^\s-+ as regular expression and RET. (See explanation below.)
   4) Leave the replacement string empty, i.e., press RET again.
   5) You are prompted by query-replace-regexp in the minibuffer.
   6) Press ! to perform all replacements at once.

Explanation of the regular expression:

1) The caret ^ stands for the beginning of line.
2) The \s- stands for any character designated as space by the current modes syntax table.
3) The + stands for one or more contiguous matches.

- C-x 4 f       - to find a file in another window.

- C-x 4 b       - to select a different buffer in another window.

* Rename an open file in Emacs?
+ Something like save-as, but the original one should go away.
+ Yes, with dired mode, you can:

- C-x d			- to open dired
- RET 			- to select directory of current file
- C-x C-j 		- (dired-jump to the name of the current file, in Dired)
- R 				- to rename the file (or dired-do-rename).
- q 				- to go back to the (renamed) file buffer

- C-x C-w
  - "save as" feature of Emacs, that's for an open file
- C-x 5 2
  - to open a new frame
- C-x 5 f [title of your new frame]
  - open a frame on particular name of file.
- C-x 5 b
  - to move to a buffer and put it in a new frame.
- C-x 5 o
  - to go to another frame

* Selecting words or sexps without moving the cursor
- C-M-SPC M-w       - This does not move the cursor.

- C-M-SPC C-M-SPC M-w - If you want to select the next two words after point.

- C-M-SPC C-w, or (better with) C-M-k - Killing next word or sexp.

* DELETE COMMANDS:
- SIFT-C-BS
  - Delete entire line the point is on
- C-0 C-k or C-u 0 C-k
  - Delete from point to beginning of line

- C-u BS
  - will delete 4 spaces backwards.

Equivalent bindings would be:

M-4 <backspace>
C-4 <backspace>

- M-\
  - Delete all SPACES & TABS around point (delete-horizontal-space).

- M-SPC
  - Deletes all spaces and tabs around point, leaving one space

- M-^
  - (delete-indentation) command for joining multiple lines into one line

- C-x C-o
  - get rid off all blank line around current line except one.

- M-x (delete-whitespace-rectangle)

* KILL COMMANDS:

- M-BS
  - WORD LEFT of cursor

- M-d
  - WORD RIGHT of cursor

- M-z CHAR
  - from cursor upto char

- C-k
  - from cursor to End of Line

- M-w
  - just to KILL RING

- C-w
  - REGION

- C-y
  - YANK LAST KILL
- C-t
  - Transpose two characters on either side of
    point and move point forward by one
- M-y
  - REPLACE YANKED with PREVIOUS KILL

* REPEAT ANY COMMAND:
- C-x z

- C-u C-n C-x z z z z     - next-line CHAIN

- C-/ C-x z z z z         - UNDO-CHAIN

* SPELL CHECKING:

- M-$
  - ispell PROGRAM sati
- M-x flyspell-mode

#+THEME
- M-x load-theme
- M-x disable-theme

* UNDO-REDO:
- C-/       - UNDO

- C-g C-/   - undo-redo 	REDO.
